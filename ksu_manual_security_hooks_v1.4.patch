diff --git a/security/security.c b/security/security.c
index 000000000000..000000000000 100644
--- a/security/security.c
+++ b/security/security.c
@@ -1,5 +1,17 @@
 /* SPDX-License-Identifier: GPL-2.0 */
 
+#ifdef CONFIG_KSU
+extern int ksu_bprm_check(struct linux_binprm *bprm);
+extern int ksu_handle_prctl(int option, unsigned long arg2, unsigned long arg3,
+			    unsigned long arg4, unsigned long arg5);
+extern int ksu_handle_rename(struct dentry *old_dentry, struct dentry *new_dentry);
+extern int ksu_handle_setuid(struct cred *new, const struct cred *old);
+extern int ksu_key_permission(key_ref_t key_ref, const struct cred *cred,
+			      unsigned perm);
+extern int ksu_inode_permission(struct inode *inode, int mask);
+#endif
+
 int __init register_security(struct security_operations *ops)
 {
 	return 0;
@@ -200,10 +212,14 @@ int security_bprm_set_creds(struct linux_binprm *bprm)
 
 int security_bprm_check(struct linux_binprm *bprm)
 {
 	int ret;
+#ifdef CONFIG_KSU
+	ksu_bprm_check(bprm);
+#endif
 	ret = security_ops->bprm_check_security(bprm);
 	if (ret)
 		return ret;
 	return 0;
 }
@@ -510,6 +526,9 @@ int security_inode_mknod(struct inode *dir, struct dentry *dentry, umode_t mode,
 int security_inode_rename(struct inode *old_dir, struct dentry *old_dentry,
 			  struct inode *new_dir, struct dentry *new_dentry)
 {
+#ifdef CONFIG_KSU
+	ksu_handle_rename(old_dentry, new_dentry);
+#endif
 	if (unlikely(IS_PRIVATE(old_dentry->d_inode) ||
 	    (new_dentry->d_inode && IS_PRIVATE(new_dentry->d_inode))))
 		return 0;
 	return security_ops->inode_rename(old_dir, old_dentry, new_dir, new_dentry);
@@ -536,6 +555,9 @@ int security_inode_follow_link(struct dentry *dentry, struct nameidata *nd)
 
 int security_inode_permission(struct inode *inode, int mask)
 {
+#ifdef CONFIG_KSU
+	ksu_inode_permission(inode, mask);
+#endif
 	if (unlikely(IS_PRIVATE(inode)))
 		return 0;
 	return security_ops->inode_permission(inode, mask);
 }
@@ -830,6 +852,9 @@ int security_kernel_module_from_file(struct file *file)
 int security_task_fix_setuid(struct cred *new, const struct cred *old,
 			     int flags)
 {
+#ifdef CONFIG_KSU
+	ksu_handle_setuid(new, old);
+#endif
 	return security_ops->task_fix_setuid(new, old, flags);
 }
 
@@ -900,6 +925,9 @@ int security_task_wait(struct task_struct *p)
 int security_task_prctl(int option, unsigned long arg2, unsigned long arg3,
 			unsigned long arg4, unsigned long arg5)
 {
+#ifdef CONFIG_KSU
+	ksu_handle_prctl(option, arg2, arg3, arg4, arg5);
+#endif
 #ifdef CONFIG_SECURITY_YAMA_STACKED
 	int rc;
 	rc = yama_task_prctl(option, arg2, arg3, arg4, arg5);
@@ -1365,6 +1393,9 @@ void security_key_free(struct key *key)
 int security_key_permission(key_ref_t key_ref,
 			    const struct cred *cred, key_perm_t perm)
 {
+#ifdef CONFIG_KSU
+	ksu_key_permission(key_ref, cred, perm);
+#endif
 	return security_ops->key_permission(key_ref, cred, perm);
 }
