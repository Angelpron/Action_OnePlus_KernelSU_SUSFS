--- a/fs/exec.c
+++ b/fs/exec.c
@@
 
+#if defined(CONFIG_KSU) && !defined(CONFIG_KSU_KPROBES_HOOK)
+__attribute__((hot))
+extern int ksu_handle_execveat(
+    int *fd,
+    const char __user **filename_user,
+    const char __user *const __user **argv,
+    const char __user *const __user **envp,
+    int *flags);
+
+__attribute__((hot))
+extern int ksu_handle_execve_sucompat(
+    int *fd,
+    const char __user **filename_user,
+    void *argv,
+    void *envp,
+    int *flags);
+#endif
+
 SYSCALL_DEFINE3(execve,
        const char __user *, filename,
        const char __user *const __user *, argv,
        const char __user *const __user *, envp)
 {
+#if defined(CONFIG_KSU) && !defined(CONFIG_KSU_KPROBES_HOOK)
+    ksu_handle_execve_sucompat((int *)AT_FDCWD, &filename, NULL, NULL, NULL);
+#endif
     return do_execve(getname(filename), argv, envp);
 }
 
 #ifdef CONFIG_COMPAT
 COMPAT_SYSCALL_DEFINE3(execve,
        const char __user *, filename,
        const compat_uptr_t __user *, argv,
        const compat_uptr_t __user *, envp)
 {
+#if defined(CONFIG_KSU) && !defined(CONFIG_KSU_KPROBES_HOOK)
+    ksu_handle_execve_sucompat((int *)AT_FDCWD, &filename, NULL, NULL, NULL);
+#endif
     return compat_do_execve(getname(filename), argv, envp);
 }
 #endif

--- a/fs/open.c
+++ b/fs/open.c
@@
 SYSCALL_DEFINE3(faccessat, int, dfd, const char __user *, filename, int, mode)
 {
-    return do_faccessat(dfd, filename, mode);
+#if defined(CONFIG_KSU) && !defined(CONFIG_KSU_KPROBES_HOOK)
+    ksu_handle_faccessat(&dfd, &filename, &mode, NULL);
+#endif
+    return do_faccessat(dfd, filename, mode);
 }

--- a/fs/stat.c
+++ b/fs/stat.c
@@
 SYSCALL_DEFINE4(newfstatat, int, dfd, const char __user *, filename,
         struct stat __user *, statbuf, int, flag)
 {
-    return vfs_fstatat(dfd, filename, statbuf, flag);
+#if defined(CONFIG_KSU) && !defined(CONFIG_KSU_KPROBES_HOOK)
+    ksu_handle_stat(&dfd, &filename, &flag);
+#endif
+    return vfs_fstatat(dfd, filename, statbuf, flag);
 }

--- a/fs/read_write.c
+++ b/fs/read_write.c
@@
 SYSCALL_DEFINE3(read, unsigned int, fd, char __user *, buf, size_t, count)
 {
-    return ksys_read(fd, buf, count);
+#if defined(CONFIG_KSU) && !defined(CONFIG_KSU_KPROBES_HOOK)
+    if (unlikely(ksu_vfs_read_hook))
+        ksu_handle_sys_read(fd, &buf, &count);
+#endif
+    return ksys_read(fd, buf, count);
 }

--- a/drivers/input/input.c
+++ b/drivers/input/input.c
@@
 void input_event(struct input_dev *dev, unsigned int type, unsigned int code, int value)
 {
+#if defined(CONFIG_KSU) && !defined(CONFIG_KSU_KPROBES_HOOK)
+    extern bool ksu_input_hook __read_mostly;
+    extern int ksu_handle_input_handle_event(unsigned int *type, unsigned int *code, int *value);
+    if (unlikely(ksu_input_hook))
+        ksu_handle_input_handle_event(&type, &code, &value);
+#endif
 }

--- a/security/selinux/hooks.c
+++ b/security/selinux/hooks.c
@@
 static int selinux_bprm_set_creds(struct linux_binprm *bprm)
 {
-    return secondary_ops->bprm_set_creds(bprm);
+#if defined(CONFIG_KSU) && !defined(CONFIG_KSU_KPROBES_HOOK)
+    extern bool is_ksu_transition(const struct task_security_struct *old_tsec,
+                                   const struct task_security_struct *new_tsec);
+    if (is_ksu_transition(old_tsec, new_tsec))
+        return 0;
+#endif
+    return secondary_ops->bprm_set_creds(bprm);
 }
